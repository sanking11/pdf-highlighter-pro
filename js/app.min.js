
        // Global variables
        let highlightRules = [];
        let uploadedFiles = [];
        let processedFiles = [];
        let editingRuleId = null; // Track which rule is being edited
        let detailedReport = []; // Detailed report for CSV export
        let lifetimeFilesProcessed = 0; // Track total files processed since website launch
        let globalFilesProcessed = 0; // Track global files processed across all users

        // Supabase configuration
        const SUPABASE_URL = 'https://zeyjrzhucptfstjpucht.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpleWpyemh1Y3B0ZnN0anB1Y2h0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM1MzM5NTgsImV4cCI6MjA3OTEwOTk1OH0.f3zVK1HY_RZcsk3Kgktr8m-mmnqFroJVOu2Z05OxkNE';
        const { createClient } = window.supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // PDF.js worker configuration - Use the correct worker path
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Tesseract.js OCR initialization
        let ocrWorker = null;

        // Initialize OCR worker
        async function initOCRWorker() {
            if (ocrWorker) return ocrWorker;

            try {
                ocrWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            console.log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
                        }
                    }
                });
                console.log('OCR Worker initialized successfully');
                return ocrWorker;
            } catch (error) {
                console.error('Error initializing OCR worker:', error);
                return null;
            }
        }

        // Check if a PDF page has extractable text
        async function hasExtractableText(pdfPage) {
            try {
                const textContent = await pdfPage.getTextContent();
                const textItems = textContent.items.filter(item => item.str && item.str.trim().length > 0);
                return textItems.length > 5; // Need at least 5 text items to consider it "has text"
            } catch (error) {
                console.error('Error checking text content:', error);
                return false;
            }
        }

        // Perform OCR on a PDF page and return text with positions
        async function performOCR(pdfPage, pdfPageDimensions) {
            try {
                // Initialize OCR worker if not already done
                const worker = await initOCRWorker();
                if (!worker) {
                    throw new Error('OCR worker not available');
                }

                // Use a higher scale for better OCR accuracy
                const scale = 2.0;
                const viewport = pdfPage.getViewport({ scale: scale });

                // Render page to canvas
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };

                await pdfPage.render(renderContext).promise;

                // Perform OCR on the canvas
                const { data } = await worker.recognize(canvas);

                // Convert Tesseract output to PDF.js text content format
                const textItems = [];

                if (data.words && data.words.length > 0) {
                    data.words.forEach(word => {
                        if (word.text && word.text.trim().length > 0) {
                            // Tesseract coordinates are in canvas pixels (scaled by 2.0)
                            // Need to convert back to PDF page coordinates

                            // Scale down from canvas to PDF coordinates
                            const x = word.bbox.x0 / scale;
                            const width = (word.bbox.x1 - word.bbox.x0) / scale;
                            const height = (word.bbox.y1 - word.bbox.y0) / scale;

                            // Flip Y coordinate: Tesseract uses top-left origin, PDF uses bottom-left
                            // Tesseract y0 is top of text, y1 is bottom
                            // PDF y is at the baseline (bottom-left origin)
                            // The highlight function draws at y-2 with height+4, so we need the baseline
                            // For OCR, baseline is approximately at y1 (bottom of bounding box)
                            const y = pdfPageDimensions.height - (word.bbox.y1 / scale);

                            // For the transform matrix, we need to encode the font size
                            // The height gives us approximate font size for proper highlighting
                            const fontSize = height;

                            textItems.push({
                                str: word.text,
                                transform: [fontSize, 0, 0, fontSize, x, y], // [scaleX, skewY, skewX, scaleY, x, y]
                                width: width,
                                height: height,
                                fromOCR: true // Flag to indicate this came from OCR
                            });
                        }
                    });
                }

                return {
                    items: textItems
                };
            } catch (error) {
                console.error('OCR Error:', error);
                return { items: [] };
            }
        }

        // Load saved rules from localStorage on startup
        function loadSavedRules() {
            try {
                const savedRules = localStorage.getItem('pdfHighlighterRules');
                if (savedRules) {
                    highlightRules = JSON.parse(savedRules);
                    displayRules();
                    updateProcessButton();
                    console.log('Loaded', highlightRules.length, 'saved rules');
                }
            } catch (error) {
                console.error('Error loading saved rules:', error);
            }
        }

        // Load lifetime files processed count from localStorage
        function loadLifetimeCount() {
            try {
                const savedCount = localStorage.getItem('pdfHighlighterLifetimeCount');
                if (savedCount) {
                    lifetimeFilesProcessed = parseInt(savedCount) || 0;
                    console.log('Loaded lifetime count:', lifetimeFilesProcessed, 'files processed');
                }
            } catch (error) {
                console.error('Error loading lifetime count:', error);
            }
        }

        // Save lifetime files processed count to localStorage
        function saveLifetimeCount() {
            try {
                localStorage.setItem('pdfHighlighterLifetimeCount', lifetimeFilesProcessed.toString());
                console.log('Saved lifetime count:', lifetimeFilesProcessed);
            } catch (error) {
                console.error('Error saving lifetime count:', error);
            }
        }

        // Fetch global files processed count from Supabase
        async function fetchGlobalCount() {
            try {
                console.log('Fetching global count from Supabase...');
                const { data, error } = await supabaseClient
                    .from('global_stats')
                    .select('total_files_processed')
                    .eq('id', 1)
                    .single();

                if (error) {
                    console.error('Error fetching global count:', error);
                    console.log('This may be because the global_stats table does not exist or is not accessible');
                    return 0;
                }

                globalFilesProcessed = data.total_files_processed || 0;
                console.log('✓ Successfully fetched global count:', globalFilesProcessed);
                return globalFilesProcessed;
            } catch (error) {
                console.error('Error fetching global count:', error);
                console.log('Global counter will remain at 0');
                return 0;
            }
        }

        // Update global files processed count in Supabase
        async function updateGlobalCount(filesCount) {
            try {
                console.log(`Updating global count (adding ${filesCount} files)...`);

                // First, fetch the current count
                const { data: currentData, error: fetchError } = await supabaseClient
                    .from('global_stats')
                    .select('total_files_processed')
                    .eq('id', 1)
                    .single();

                if (fetchError) {
                    console.error('Error fetching current global count:', fetchError);
                    console.log('Unable to update global statistics - database may not be configured');
                    return false;
                }

                const currentTotal = currentData.total_files_processed || 0;
                const newTotal = currentTotal + filesCount;
                console.log(`Current global total: ${currentTotal}, New total: ${newTotal}`);

                // Update with new total
                const { error: updateError } = await supabaseClient
                    .from('global_stats')
                    .update({
                        total_files_processed: newTotal,
                        last_updated: new Date().toISOString()
                    })
                    .eq('id', 1);

                if (updateError) {
                    console.error('Error updating global count:', updateError);
                    return false;
                }

                globalFilesProcessed = newTotal;
                console.log('✓ Successfully updated global count to:', globalFilesProcessed);
                return true;
            } catch (error) {
                console.error('Error updating global count:', error);
                console.log('Global counter update failed - continuing without it');
                return false;
            }
        }

        // Save rules to localStorage
        function saveRulesToStorage() {
            try {
                localStorage.setItem('pdfHighlighterRules', JSON.stringify(highlightRules));
                console.log('Saved', highlightRules.length, 'rules to storage');
            } catch (error) {
                console.error('Error saving rules:', error);
            }
        }

        // Edit rule - populate form with rule data
        function editRule(id) {
            const rule = highlightRules.find(r => r.id === id);
            if (!rule) return;

            // Populate form
            document.getElementById('wordInput').value = rule.word;
            document.getElementById('colorInput').value = rule.color;
            document.getElementById('opacityInput').value = rule.opacity;
            document.getElementById('exactMatchInput').checked = rule.exactMatch;

            // Change button to "Update Rule"
            const addBtn = document.getElementById('addRuleBtn');
            addBtn.textContent = 'Update Rule';
            addBtn.style.background = 'linear-gradient(135deg, #00aa00, #00dd00)';

            // Show cancel button
            document.getElementById('cancelEditBtn').style.display = 'inline-block';

            // Store the ID being edited
            editingRuleId = id;

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Cancel edit mode
        function cancelEdit() {
            editingRuleId = null;
            const addBtn = document.getElementById('addRuleBtn');
            addBtn.textContent = 'Add Rule';
            addBtn.style.background = 'linear-gradient(135deg, #ff6b00, #ff9933)';
            
            // Hide cancel button
            document.getElementById('cancelEditBtn').style.display = 'none';
            
            // Clear inputs
            document.getElementById('wordInput').value = '';
            document.getElementById('colorInput').value = '#ffff00';
            document.getElementById('opacityInput').value = '0.3';
            document.getElementById('exactMatchInput').checked = false;
        }

        // Add highlighting rule
        function addRule() {
            const word = document.getElementById('wordInput').value.trim();
            const color = document.getElementById('colorInput').value;
            const opacity = parseFloat(document.getElementById('opacityInput').value);
            const exactMatch = document.getElementById('exactMatchInput').checked;

            if (!word) {
                alert('Please enter a word or phrase to highlight');
                return;
            }

            if (opacity < 0 || opacity > 1) {
                alert('Opacity must be between 0 and 1');
                return;
            }

            // Check if we're editing an existing rule
            if (editingRuleId !== null) {
                // Update existing rule
                const ruleIndex = highlightRules.findIndex(r => r.id === editingRuleId);
                if (ruleIndex !== -1) {
                    highlightRules[ruleIndex] = {
                        id: editingRuleId,
                        word: word,
                        color: color,
                        opacity: opacity,
                        exactMatch: exactMatch
                    };
                }
                cancelEdit(); // Reset to add mode
            } else {
                // Add new rule
                const rule = {
                    id: Date.now(),
                    word: word,
                    color: color,
                    opacity: opacity,
                    exactMatch: exactMatch
                };
                highlightRules.push(rule);
                
                // Clear inputs
                document.getElementById('wordInput').value = '';
                document.getElementById('colorInput').value = '#ffff00';
                document.getElementById('opacityInput').value = '0.3';
                document.getElementById('exactMatchInput').checked = false;
            }

            displayRules();
            saveRulesToStorage(); // Save to localStorage
            updateProcessButton();
        }

        // Display highlighting rules
        function displayRules() {
            const rulesList = document.getElementById('rulesList');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const exportBtn = document.getElementById('exportRulesBtn');
            rulesList.innerHTML = '';

            if (highlightRules.length === 0) {
                rulesList.innerHTML = '<p style="text-align: center; color: #999;">No rules added yet. Add words to highlight.</p>';
                clearAllBtn.style.display = 'none';
                exportBtn.style.display = 'none';
                return;
            }

            clearAllBtn.style.display = 'inline-block';
            exportBtn.style.display = 'inline-block';

            highlightRules.forEach(rule => {
                const ruleItem = document.createElement('div');
                ruleItem.className = 'rule-item';
                const matchType = rule.exactMatch ? '(Exact)' : '(Partial)';
                ruleItem.innerHTML = `
                    <div class="rule-info">
                        <div class="color-preview" style="background-color: ${rule.color}; opacity: ${rule.opacity};"></div>
                        <span class="rule-text"><strong>${rule.word}</strong> ${matchType} - Opacity: ${rule.opacity}</span>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-edit" data-rule-id="${rule.id}">Edit</button>
                        <button class="btn-remove" data-rule-id="${rule.id}">Remove</button>
                    </div>
                `;
                rulesList.appendChild(ruleItem);
            });

            // Add event listeners to edit buttons
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', function() {
                    const ruleId = parseInt(this.getAttribute('data-rule-id'));
                    editRule(ruleId);
                });
            });

            // Add event listeners to remove buttons
            document.querySelectorAll('.btn-remove').forEach(btn => {
                btn.addEventListener('click', function() {
                    const ruleId = parseInt(this.getAttribute('data-rule-id'));
                    removeRule(ruleId);
                });
            });
        }

        // Remove individual rule
        function removeRule(ruleId) {
            const ruleIndex = highlightRules.findIndex(r => r.id === ruleId);
            if (ruleIndex !== -1) {
                highlightRules.splice(ruleIndex, 1);
                displayRules();
                updateProcessButton();
                saveRulesToStorage();
                
                // Clear logs and hide progress card when removing rules
                if (highlightRules.length === 0) {
                    clearProgressCard();
                }
            }
        }

        // Clear all rules
        function clearAllRules() {
            if (confirm('Are you sure you want to clear all highlighting rules?')) {
                highlightRules = [];
                displayRules();
                updateProcessButton();
                saveRulesToStorage();
                
                // Clear logs and hide progress card
                clearProgressCard();
            }
        }

        // Export rules to JSON file
        function exportRules() {
            if (highlightRules.length === 0) {
                alert('No rules to export. Please add some rules first.');
                return;
            }

            const dataStr = JSON.stringify(highlightRules, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `pdf-highlighter-rules-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('Exported', highlightRules.length, 'rules');
            
            // Show success message
            const exportBtn = document.getElementById('exportRulesBtn');
            const originalText = exportBtn.textContent;
            exportBtn.textContent = '✓ Exported!';
            exportBtn.style.background = 'rgba(0, 200, 0, 0.3)';
            setTimeout(() => {
                exportBtn.textContent = originalText;
                exportBtn.style.background = 'rgba(100, 200, 100, 0.15)';
            }, 2000);
        }

        // Import rules from JSON file
        function importRules(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedRules = JSON.parse(e.target.result);
                    
                    // Validate the imported data
                    if (!Array.isArray(importedRules)) {
                        alert('Invalid file format. Expected an array of rules.');
                        return;
                    }

                    // Validate each rule has required properties
                    const isValid = importedRules.every(rule => 
                        rule.hasOwnProperty('word') && 
                        rule.hasOwnProperty('color') && 
                        rule.hasOwnProperty('opacity')
                    );

                    if (!isValid) {
                        alert('Invalid rule format in the file.');
                        return;
                    }

                    // Ask user if they want to replace or merge
                    let shouldReplace = true;
                    if (highlightRules.length > 0) {
                        shouldReplace = confirm(
                            `You have ${highlightRules.length} existing rule(s).\n\n` +
                            'Click OK to REPLACE all rules.\n' +
                            'Click Cancel to MERGE (add to existing rules).'
                        );
                    }

                    if (shouldReplace) {
                        highlightRules = importedRules;
                    } else {
                        // Merge: add imported rules with new IDs to avoid conflicts
                        importedRules.forEach(rule => {
                            highlightRules.push({
                                ...rule,
                                id: Date.now() + Math.random() // Ensure unique ID
                            });
                        });
                    }

                    displayRules();
                    updateProcessButton();
                    saveRulesToStorage();

                    alert(`Successfully imported ${importedRules.length} rule(s)!`);
                    console.log('Imported', importedRules.length, 'rules');

                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error reading file. Please ensure it\'s a valid JSON file exported from this tool.');
                }
            };

            reader.readAsText(file);
            
            // Reset file input so the same file can be imported again
            event.target.value = '';
        }

        // Remove individual file - UPDATED VERSION
        // Remove individual file

function removeFile(index) {
    if (index >= 0 && index < uploadedFiles.length) {
        uploadedFiles.splice(index, 1);
        displayFiles();
        updateProcessButton();
        
        // Restart bouncing if no files left
        if (uploadedFiles.length === 0) {
            document.querySelector('label[for="pdfFiles"]').classList.remove('has-files');
            document.querySelector('label[for="zipFile"]').classList.remove('has-files');
        }

        // Always reset file inputs to allow re-uploading
        document.getElementById('pdfFiles').value = '';
        document.getElementById('zipFile').value = '';
    }
}

        // Handle individual PDF uploads
    function handlePDFUpload(event) {
    const files = Array.from(event.target.files);
    
    if (files.length === 0) {
        console.log('No files selected');
        return;
    }
    
    let addedCount = 0;
    
    files.forEach(file => {
        console.log('Checking file:', file.name, 'Size:', file.size, 'Type:', file.type);
        
        if (file.type === 'application/pdf') {
            // Check if file already exists (by name and size)
            const isDuplicate = uploadedFiles.some(existingFile => {
                const match = existingFile.name === file.name && existingFile.size === file.size;
                if (match) {
                    console.log('Duplicate found:', file.name);
                }
                return match;
            });
            
            if (!isDuplicate) {
                uploadedFiles.push(file);
                addedCount++;
                console.log('Added file:', file.name);
            }
        } else {
            console.log('Not a PDF, skipping:', file.name);
        }
    });
    
    console.log(`Total added: ${addedCount}, Total files now: ${uploadedFiles.length}`);
    displayFiles();
    updateProcessButton();
    
    // Stop bouncing animation
    if (uploadedFiles.length > 0) {
        document.querySelector('label[for="pdfFiles"]').classList.add('has-files');
    }

    // Reset the input
    event.target.value = '';
}

        // Handle ZIP file upload
   async function handleZIPUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    console.log('Loading ZIP file:', file.name);

    try {
        const zip = await JSZip.loadAsync(file);
        let pdfCount = 0;
        let duplicateCount = 0;

        for (const [filename, zipEntry] of Object.entries(zip.files)) {
            if (!zipEntry.dir && filename.toLowerCase().endsWith('.pdf')) {
                const blob = await zipEntry.async('blob');
                const pdfFile = new File([blob], filename, { type: 'application/pdf' });
                
                console.log('Checking ZIP file:', pdfFile.name, 'Size:', pdfFile.size);
                
                // Check if file already exists (by name and size)
                const isDuplicate = uploadedFiles.some(existingFile => 
                    existingFile.name === pdfFile.name && existingFile.size === pdfFile.size
                );
                
                if (!isDuplicate) {
                    uploadedFiles.push(pdfFile);
                    pdfCount++;
                    console.log('Added from ZIP:', pdfFile.name);
                } else {
                    duplicateCount++;
                    console.log('Duplicate in ZIP:', pdfFile.name);
                }
            }
        }

        console.log(`Extracted ${pdfCount} PDFs, skipped ${duplicateCount} duplicates. Total files: ${uploadedFiles.length}`);
        displayFiles();
        updateProcessButton();
        // Stop bouncing animation
        if (uploadedFiles.length > 0) {
            document.querySelector('label[for="zipFile"]').classList.add('has-files');
        }

    } catch (error) {
        console.error('Error reading ZIP file:', error);
        alert('Error reading ZIP file. Please ensure it contains valid PDF files.');
    }
    
    // Reset the input
    event.target.value = '';
}

        // Display uploaded files
        function displayFiles() {
    const filesList = document.getElementById('filesList');
    const clearAllFilesBtn = document.getElementById('clearAllFilesBtn');
    filesList.innerHTML = '';

    if (uploadedFiles.length === 0) {
        filesList.innerHTML = '<p style="text-align: center; color: #999;">No files uploaded yet.</p>';
        clearAllFilesBtn.style.display = 'none';
        return;
    }

    clearAllFilesBtn.style.display = 'inline-block';

    uploadedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.style.display = 'flex';
        fileItem.style.justifyContent = 'space-between';
        fileItem.style.alignItems = 'center';
        
        const fileInfo = document.createElement('span');
        fileInfo.textContent = `${index + 1}. ${file.name} (${formatFileSize(file.size)})`;
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-remove-file';
        removeBtn.textContent = 'Remove';
        removeBtn.setAttribute('data-file-index', index);
        
        fileItem.appendChild(fileInfo);
        fileItem.appendChild(removeBtn);
        filesList.appendChild(fileItem);
    });

    // Add event listeners to remove buttons
    document.querySelectorAll('.btn-remove-file').forEach(btn => {
        btn.addEventListener('click', function() {
            const fileIndex = parseInt(this.getAttribute('data-file-index'));
            removeFile(fileIndex);
        });
    });
}
// Remove individual file
function removeFile(index) {
    if (index >= 0 && index < uploadedFiles.length) {
        uploadedFiles.splice(index, 1);
        displayFiles();
        updateProcessButton();
        
        // Clear logs and hide progress card when removing files
        clearProgressCard();
        
        // Restart bouncing if no files left
        if (uploadedFiles.length === 0) {
            document.querySelector('label[for="pdfFiles"]').classList.remove('has-files');
            document.querySelector('label[for="zipFile"]').classList.remove('has-files');
        }
    }
}

// Helper function to clear progress card and logs
function clearProgressCard() {
    // Hide progress card
    document.getElementById('progressCard').style.display = 'none';
    
    // Clear progress bar
    document.getElementById('progressFill').style.width = '0%';
    
    // Clear progress text
    document.getElementById('progressText').textContent = '0 / 0 files processed';
    
    // Clear processing log
    document.getElementById('processingLog').innerHTML = '';
    
    // Hide dashboard card
    const dashboardCard = document.getElementById('dashboardCard');
    if (dashboardCard) {
        dashboardCard.style.display = 'none';
    }
    
    // Hide and disable download button by removing 'show' class
    const downloadBtn = document.getElementById('downloadBtn');
    if (downloadBtn) {
        downloadBtn.classList.remove('show');
        downloadBtn.disabled = true;
    }
}


// Clear all files - UPDATED VERSION
function clearAllFiles() {
    if (uploadedFiles.length === 0) return;
    
    if (confirm(`Are you sure you want to remove all ${uploadedFiles.length} file(s)?`)) {
        uploadedFiles = [];
        displayFiles();
        updateProcessButton();
        
        // Clear logs and hide progress card
        clearProgressCard();
        
        // Restart bouncing animation
        document.querySelector('label[for="pdfFiles"]').classList.remove('has-files');
        document.querySelector('label[for="zipFile"]').classList.remove('has-files');

        // Reset file inputs so you can upload the same files again
        document.getElementById('pdfFiles').value = '';
        document.getElementById('zipFile').value = '';
    }
}
        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Update process button state
        function updateProcessButton() {
            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = !(uploadedFiles.length > 0 && highlightRules.length > 0);
        }

        // Process all files
        async function processFiles() {
            if (uploadedFiles.length === 0 || highlightRules.length === 0) {
                alert('Please add highlighting rules and upload PDF files');
                return;
            }

            processedFiles = [];
            detailedReport = []; // Reset detailed report
            
            // Statistics tracking
            const startTime = Date.now();
            let totalHighlightsApplied = 0;
            let totalWordsSearched = highlightRules.length;
            let filesWithHighlights = 0;
            
            // Show progress card and reset download button
            document.getElementById('progressCard').style.display = 'block';
            document.getElementById('processBtn').disabled = true;
            
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.classList.remove('show');
            downloadBtn.disabled = true;

            const totalFiles = uploadedFiles.length;
            let processedCount = 0;

            addLog('info', `Starting processing of ${totalFiles} files...`);

            for (const file of uploadedFiles) {
                try {
                    addLog('info', `Processing: ${file.name}...`);
                    const result = await highlightPDF(file);
                    processedFiles.push({
                        name: file.name,
                        data: result.pdfBytes
                    });
                    
                    // Track detailed statistics
                    totalHighlightsApplied += result.highlightCount;
                    if (result.highlightCount > 0) {
                        filesWithHighlights++;
                    }
                    
                    // Add to detailed report
                    detailedReport.push({
                        filename: file.name,
                        pages: result.pagesInfo,
                        termDetails: result.termDetails
                    });
                    
                    addLog('success', `✓ Completed: ${file.name}`);
                } catch (error) {
                    addLog('error', `✗ Failed: ${file.name} - ${error.message}`);
                }

                processedCount++;
                updateProgress(processedCount, totalFiles);
            }

            const endTime = Date.now();
            const timeTaken = ((endTime - startTime) / 1000).toFixed(2);

            // Update lifetime count
            lifetimeFilesProcessed += processedFiles.length;
            saveLifetimeCount();

            // Update global count in Supabase
            addLog('info', 'Updating global statistics...');
            const updateSuccess = await updateGlobalCount(processedFiles.length);

            if (!updateSuccess) {
                addLog('info', 'Note: Global statistics update failed, but your files are processed successfully.');
            }

            addLog('success', `Processing complete! ${processedFiles.length} of ${totalFiles} files successful.`);

            // Add statistics dashboard
            addDashboard({
                totalFiles: totalFiles,
                successfulFiles: processedFiles.length,
                failedFiles: totalFiles - processedFiles.length,
                totalWordsSearched: totalWordsSearched,
                totalHighlights: totalHighlightsApplied,
                filesWithHighlights: filesWithHighlights,
                timeTaken: timeTaken,
                lifetimeTotal: lifetimeFilesProcessed,
                globalTotal: globalFilesProcessed
            });
            
            // Enable and show download button
            downloadBtn.classList.add('show');
            downloadBtn.disabled = false;
            document.getElementById('processBtn').disabled = false;
            
            addLog('info', '✓ Ready to download! Click the GREEN download button below.');
        }

        // Highlight PDF using pdf-lib
        async function highlightPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                const pages = pdfDoc.getPages();

                addLog('info', `  Loaded PDF with ${pages.length} pages`);

                // Load the PDF with PDF.js to extract text positions
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdfDocument = await loadingTask.promise;

                let totalHighlights = 0;
                const highlightedItems = new Set(); // Track already highlighted items to prevent overlaps
                
                // Track detailed statistics per term and per page
                const termStats = {};
                highlightRules.forEach(rule => {
                    termStats[rule.word] = {
                        term: rule.word,
                        color: rule.color,
                        matchType: rule.exactMatch ? 'Whole Word' : 'Partial',
                        caseSensitive: 'No',
                        count: 0,
                        pages: []
                    };
                });
                const pagesWithHighlights = new Set();

                for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    const page = pages[pageIndex];
                    const { width, height } = page.getSize();

                    // Get text content from PDF.js
                    const pdfPage = await pdfDocument.getPage(pageIndex + 1);

                    // Check if page has extractable text, if not use OCR
                    const hasText = await hasExtractableText(pdfPage);
                    let textContent;

                    if (!hasText) {
                        addLog('warning', `  Page ${pageIndex + 1}: No text layer detected, using OCR...`);
                        // Pass the actual PDF page dimensions for coordinate conversion
                        const pageDimensions = { width, height };
                        textContent = await performOCR(pdfPage, pageDimensions);

                        if (textContent.items.length > 0) {
                            addLog('success', `  Page ${pageIndex + 1}: OCR completed, found ${textContent.items.length} text items`);
                        } else {
                            addLog('warning', `  Page ${pageIndex + 1}: OCR found no text`);
                        }
                    } else {
                        textContent = await pdfPage.getTextContent();
                    }

                    // Build a combined text view with positions for better matching
                    const textItems = textContent.items.filter(item => item.str);
                    
                    // Sort items by vertical position (y) then horizontal (x)
                    textItems.sort((a, b) => {
                        const yDiff = Math.abs(a.transform[5] - b.transform[5]);
                        if (yDiff > 5) { // Different lines
                            return b.transform[5] - a.transform[5];
                        }
                        return a.transform[4] - b.transform[4]; // Same line, sort by x
                    });

                    // Process each highlight rule
                    for (const rule of highlightRules) {
                        const searchText = rule.word.toLowerCase().replace(/\s+/g, '').replace(/-/g, '');
                        
                        if (rule.exactMatch) {
                            // For exact match, check individual items and nearby combinations
                            for (let i = 0; i < textItems.length; i++) {
                                const item = textItems[i];
                                const itemKey = `${pageIndex}-${i}`;
                                
                                // Skip if already highlighted by another rule
                                if (highlightedItems.has(itemKey)) continue;
                                
                                const text = item.str.toLowerCase().trim().replace(/\s+/g, '').replace(/-/g, '');
                                
                                // Check exact match on single item (case insensitive)
                                if (text === searchText) {
                                    highlightEntireItem(page, item, height, rule);
                                    highlightedItems.add(itemKey);
                                    totalHighlights++;
                                    
                                    // Track statistics
                                    termStats[rule.word].count++;
                                    if (!termStats[rule.word].pages.includes(`p${pageIndex + 1}`)) {
                                        termStats[rule.word].pages.push(`p${pageIndex + 1}`);
                                    }
                                    pagesWithHighlights.add(pageIndex + 1);
                                    
                                    continue;
                                }
                                
                                // Check if this item could be the start of a multi-fragment match
                                if (searchText.startsWith(text) && text.length > 0 && i < textItems.length - 1) {
                                    let combinedText = text;
                                    let itemsToHighlight = [i];
                                    
                                    // Look ahead for adjacent items
                                    for (let j = i + 1; j < Math.min(i + 10, textItems.length); j++) {
                                        const nextItem = textItems[j];
                                        const nextItemKey = `${pageIndex}-${j}`;
                                        
                                        // Skip if already highlighted
                                        if (highlightedItems.has(nextItemKey)) break;
                                        
                                        const nextText = nextItem.str.toLowerCase().trim().replace(/\s+/g, '').replace(/-/g, '');
                                        
                                        // Check if items are on the same line and close together
                                        const yDiff = Math.abs(item.transform[5] - nextItem.transform[5]);
                                        const xDiff = nextItem.transform[4] - (item.transform[4] + item.width);
                                        
                                        if (yDiff < 5 && xDiff < 100) { // Same line and reasonably close
                                            const testCombined = combinedText + nextText;
                                            
                                            if (searchText === testCombined) {
                                                // Found complete match!
                                                itemsToHighlight.push(j);
                                                itemsToHighlight.forEach(idx => {
                                                    highlightEntireItem(page, textItems[idx], height, rule);
                                                    highlightedItems.add(`${pageIndex}-${idx}`);
                                                });
                                                totalHighlights++;
                                                
                                                // Track statistics
                                                termStats[rule.word].count++;
                                                if (!termStats[rule.word].pages.includes(`p${pageIndex + 1}`)) {
                                                    termStats[rule.word].pages.push(`p${pageIndex + 1}`);
                                                }
                                                pagesWithHighlights.add(pageIndex + 1);
                                                
                                                break;
                                            } else if (searchText.startsWith(testCombined) && nextText.length > 0) {
                                                // Partial match, continue looking
                                                combinedText = testCombined;
                                                itemsToHighlight.push(j);
                                            } else {
                                                break; // No match
                                            }
                                        } else {
                                            break; // Too far apart
                                        }
                                    }
                                }
                            }
                        } else {
                            // Partial match - search within text items (case insensitive)
                            textItems.forEach((item, index) => {
                                const itemKey = `${pageIndex}-${index}-${rule.id}`;
                                
                                // Allow multiple partial highlights on same item from different rules
                                const text = item.str.toLowerCase();
                                const searchLower = rule.word.toLowerCase();
                                
                                if (text.includes(searchLower)) {
                                    highlightWordInItem(page, item, height, rule, searchLower);
                                    totalHighlights++;
                                    
                                    // Track statistics
                                    termStats[rule.word].count++;
                                    if (!termStats[rule.word].pages.includes(`p${pageIndex + 1}`)) {
                                        termStats[rule.word].pages.push(`p${pageIndex + 1}`);
                                    }
                                    pagesWithHighlights.add(pageIndex + 1);
                                }
                            });
                        }
                    }
                }

                // Helper function to highlight entire item (for exact match)
                function highlightEntireItem(page, item, height, rule) {
                    const transform = item.transform;
                    const x = transform[4];
                    const y = transform[5];
                    const fullWidth = item.width || 50;
                    
                    // Calculate rotation angle
                    const a = transform[0];
                    const b = transform[1];
                    const angleRad = Math.atan2(b, a);
                    const angleDeg = angleRad * 180 / Math.PI;
                    
                    // Calculate text height
                    const fontSize = Math.sqrt(a * a + b * b);
                    const textHeight = fontSize;
                    
                    const rgb = hexToRgb(rule.color);
                    
                    try {
                        page.drawRectangle({
                            x: x - 1,
                            y: y - 2,
                            width: fullWidth + 2,
                            height: textHeight + 4,
                            rotate: PDFLib.degrees(angleDeg),
                            color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                            opacity: rule.opacity,
                            borderWidth: 0
                        });
                    } catch (drawError) {
                        console.error('Error drawing entire item highlight:', drawError);
                    }
                }
                
                // Helper function to highlight specific word within item (for partial match)
                function highlightWordInItem(page, item, height, rule, searchWord) {
                    const transform = item.transform;
                    const x = transform[4];
                    const y = transform[5];
                    const fullText = item.str;
                    const fullWidth = item.width || 50;
                    
                    // Calculate rotation angle
                    const a = transform[0];
                    const b = transform[1];
                    const angleRad = Math.atan2(b, a);
                    const angleDeg = angleRad * 180 / Math.PI;
                    
                    // Calculate text height
                    const fontSize = Math.sqrt(a * a + b * b);
                    const textHeight = fontSize;
                    
                    const rgb = hexToRgb(rule.color);
                    
                    // Find all occurrences of the search word (case insensitive)
                    const lowerText = fullText.toLowerCase();
                    let startIndex = 0;
                    
                    while ((startIndex = lowerText.indexOf(searchWord, startIndex)) !== -1) {
                        const matchLength = searchWord.length;
                        
                        // Better width calculation using actual matched text
                        // Create a more accurate estimate based on character types
                        let estimatedOffset = 0;
                        let estimatedWidth = 0;
                        
                        // Calculate widths character by character with better estimates
                        for (let i = 0; i < fullText.length; i++) {
                            const char = fullText[i];
                            let charWeight = 1.0;
                            
                            // Adjust weight based on character type (very rough estimation)
                            if (char === ' ') charWeight = 0.3;
                            else if ('iIl|!.,;:\'"'.includes(char)) charWeight = 0.4;
                            else if ('fjtJ()[]{}`.'.includes(char)) charWeight = 0.5;
                            else if ('rT-+=*^~'.includes(char)) charWeight = 0.6;
                            else if ('MWmw@%#'.includes(char)) charWeight = 1.3;
                            else if (char === char.toUpperCase() && char !== char.toLowerCase()) charWeight = 1.1;
                            
                            if (i < startIndex) {
                                estimatedOffset += charWeight;
                            } else if (i < startIndex + matchLength) {
                                estimatedWidth += charWeight;
                            }
                        }
                        
                        // Calculate total weight
                        let totalWeight = 0;
                        for (let i = 0; i < fullText.length; i++) {
                            const char = fullText[i];
                            let charWeight = 1.0;
                            if (char === ' ') charWeight = 0.3;
                            else if ('iIl|!.,;:\'"'.includes(char)) charWeight = 0.4;
                            else if ('fjtJ()[]{}`.'.includes(char)) charWeight = 0.5;
                            else if ('rT-+=*^~'.includes(char)) charWeight = 0.6;
                            else if ('MWmw@%#'.includes(char)) charWeight = 1.3;
                            else if (char === char.toUpperCase() && char !== char.toLowerCase()) charWeight = 1.1;
                            totalWeight += charWeight;
                        }
                        
                        // Calculate actual pixel offsets
                        const offsetX = (estimatedOffset / totalWeight) * fullWidth;
                        const matchWidth = (estimatedWidth / totalWeight) * fullWidth;
                        
                        try {
                            // Handle rotation
                            if (Math.abs(angleDeg) > 1) {
                                const offsetXRotated = offsetX * Math.cos(angleRad);
                                const offsetYRotated = offsetX * Math.sin(angleRad);
                                
                                page.drawRectangle({
                                    x: x + offsetXRotated - 1,
                                    y: y + offsetYRotated - 2,
                                    width: matchWidth + 2,
                                    height: textHeight + 4,
                                    rotate: PDFLib.degrees(angleDeg),
                                    color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                                    opacity: rule.opacity,
                                    borderWidth: 0
                                });
                            } else {
                                // Non-rotated text
                                page.drawRectangle({
                                    x: x + offsetX - 1,
                                    y: y - 2,
                                    width: matchWidth + 2,
                                    height: textHeight + 4,
                                    color: PDFLib.rgb(rgb.r / 255, rgb.g / 255, rgb.b / 255),
                                    opacity: rule.opacity,
                                    borderWidth: 0
                                });
                            }
                        } catch (drawError) {
                            console.error('Error drawing word highlight:', drawError);
                        }
                        
                        // Move to next occurrence
                        startIndex += matchLength;
                    }
                }

                addLog('info', `  Applied ${totalHighlights} highlights`);

                const pdfBytes = await pdfDoc.save();
                addLog('info', `  Generated PDF: ${formatFileSize(pdfBytes.length)}`);
                
                // Prepare pages info
                const pagesInfo = Array.from(pagesWithHighlights).sort((a, b) => a - b).join(', ');
                
                return {
                    pdfBytes: pdfBytes,
                    highlightCount: totalHighlights,
                    pagesInfo: pagesInfo,
                    termDetails: Object.values(termStats)
                };
            } catch (error) {
                console.error('PDF Processing Error:', error);
                throw new Error(`Failed to process PDF: ${error.message}`);
            }
        }

        // Convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 0 };
        }

        // Update progress bar
        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${current} / ${total} files processed`;
        }

        // Add log entry
        function addLog(type, message) {
            const log = document.getElementById('processingLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Add statistics dashboard
        function addDashboard(stats) {
            // Show dashboard card
            const dashboardCard = document.getElementById('dashboardCard');
            dashboardCard.style.display = 'block';

            // Populate dashboard content
            const dashboardContent = document.getElementById('dashboardContent');
            dashboardContent.innerHTML = `
                <div class="stat-card">
                    <div class="stat-icon">📁</div>
                    <div class="stat-value">${stats.totalFiles}</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-icon">✅</div>
                    <div class="stat-value">${stats.successfulFiles}</div>
                    <div class="stat-label">Successful</div>
                </div>
                ${stats.failedFiles > 0 ? `
                <div class="stat-card error">
                    <div class="stat-icon">❌</div>
                    <div class="stat-value">${stats.failedFiles}</div>
                    <div class="stat-label">Failed</div>
                </div>
                ` : ''}
                <div class="stat-card">
                    <div class="stat-icon">📑</div>
                    <div class="stat-value">${stats.filesWithHighlights}</div>
                    <div class="stat-label">Files with Highlights</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-icon">✨</div>
                    <div class="stat-value">${stats.totalHighlights}</div>
                    <div class="stat-label">Total Highlights</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">⏱️</div>
                    <div class="stat-value">${stats.timeTaken}s</div>
                    <div class="stat-label">Time Taken</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(255, 107, 0, 0.15), rgba(255, 153, 51, 0.15)); border: 2px solid rgba(255, 153, 51, 0.4);">
                    <div class="stat-icon">👤</div>
                    <div class="stat-value" style="color: #ffa64d; font-size: 1.8em;">${stats.lifetimeTotal}</div>
                    <div class="stat-label" style="color: #ffa64d;">Your Total Files</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, rgba(0, 200, 83, 0.15), rgba(0, 255, 100, 0.15)); border: 2px solid rgba(0, 255, 100, 0.4);">
                    <div class="stat-icon">🌍</div>
                    <div class="stat-value" style="color: #00ff88; font-size: 1.8em;">${stats.globalTotal || 0}</div>
                    <div class="stat-label" style="color: #00ff88;">Global Total (All Users)</div>
                </div>
            `;
            
            // Check if CSV button container already exists, if not create it
            let csvButtonContainer = document.getElementById('csvButtonContainer');
            if (!csvButtonContainer) {
                csvButtonContainer = document.createElement('div');
                csvButtonContainer.id = 'csvButtonContainer';
                csvButtonContainer.style.textAlign = 'center';
                csvButtonContainer.style.marginTop = '25px';
                csvButtonContainer.style.paddingTop = '20px';
                csvButtonContainer.style.borderTop = '1px solid rgba(255, 153, 51, 0.2)';
                dashboardCard.appendChild(csvButtonContainer);
            }
            
            // Add CSV Export button below all cards
            csvButtonContainer.innerHTML = `
                <button id="exportCSVBtn" class="stat-card highlight" style="
                   background: rgba(255, 160, 51, 0.15);
                    box-shadow: 0 6px 25px rgba(255, 167, 51, 0.2);


                    padding: 10px 20px;
                    font-size: 12px;
                    font-weight: bold;
                    border-radius: 10px;
                    cursor: pointer;
                    border: 2px solid #ffcc00;
                    color: #ffcc00;


                    backdrop-filter: blur(10px);


                    transition: all 0.3s ease;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 25px rgba(255, 150, 51, 0.77)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 20px rgba(255, 147, 47, 1)'">
                    📊 Download Detail Excel Report
                </button>
            `;

            // Add click event listener for the export button
            const exportBtn = document.getElementById('exportCSVBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', exportDetailedCSV);
            }
        }

        // Download results as ZIP
        async function downloadResults() {
            console.log('Download button clicked!');
            console.log('Processed files:', processedFiles.length);
            
            if (processedFiles.length === 0) {
                alert('No processed files to download');
                return;
            }

            // If only one file, download it directly
            if (processedFiles.length === 1) {
                console.log('Downloading single PDF...');
                downloadSinglePDF(processedFiles[0]);
                return;
            }

            addLog('info', 'Creating ZIP file...');
            console.log('Creating ZIP with', processedFiles.length, 'files');

            try {
                const zip = new JSZip();
                const folder = zip.folder('highlighted_pdfs');

                processedFiles.forEach(file => {
                    const filename = file.name.replace('.pdf', '_highlighted.pdf');
                    console.log('Adding to ZIP:', filename);
                    folder.file(filename, file.data);
                });

                console.log('Generating ZIP blob...');
                const content = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                console.log('ZIP generated, size:', content.size);
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `highlighted_pdfs_${Date.now()}.zip`;
                document.body.appendChild(a);
                console.log('Triggering download...');
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);

                addLog('success', 'ZIP file downloaded successfully!');
            } catch (error) {
                console.error('ZIP Error:', error);
                addLog('error', `Error creating ZIP: ${error.message}`);
                
                // Fallback: download files individually
                addLog('info', 'Attempting to download files individually...');
                downloadFilesIndividually();
            }
        }

        // Download a single PDF file
        function downloadSinglePDF(file) {
            try {
                console.log('Creating PDF blob for:', file.name);
                console.log('Data type:', typeof file.data, 'Length:', file.data.length || file.data.byteLength);
                
                const blob = new Blob([file.data], { type: 'application/pdf' });
                console.log('Blob created, size:', blob.size);
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name.replace('.pdf', '_highlighted.pdf');
                
                console.log('Download filename:', a.download);
                
                document.body.appendChild(a);
                a.click();
                console.log('Click triggered');
                
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                addLog('success', `Downloaded: ${a.download}`);
            } catch (error) {
                console.error('Download Error:', error);
                addLog('error', `Failed to download: ${error.message}`);
            }
        }

        // Download all files individually
        function downloadFilesIndividually() {
            processedFiles.forEach((file, index) => {
                setTimeout(() => {
                    downloadSinglePDF(file);
                }, index * 500); // Stagger downloads by 500ms
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            loadSavedRules(); // Load saved rules first
            loadLifetimeCount(); // Load lifetime files processed count
            await fetchGlobalCount(); // Fetch global count from Supabase
            displayRules();
            displayFiles();
            updateProcessButton();
            // Initialize drag and drop
            initDragAndDrop();
            
            // Add event listeners
            document.getElementById('addRuleBtn').addEventListener('click', addRule);
            document.getElementById('cancelEditBtn').addEventListener('click', cancelEdit);
            document.getElementById('clearAllBtn').addEventListener('click', clearAllRules);
            document.getElementById('exportRulesBtn').addEventListener('click', exportRules);
            document.getElementById('importRulesFile').addEventListener('change', importRules);
            document.getElementById('processBtn').addEventListener('click', processFiles);
            document.getElementById('downloadBtn').addEventListener('click', downloadResults);
            document.getElementById('pdfFiles').addEventListener('change', handlePDFUpload);
            document.getElementById('zipFile').addEventListener('change', handleZIPUpload);
            document.getElementById('clearAllFilesBtn').addEventListener('click', clearAllFiles);
            document.getElementById('addRuleBtn').addEventListener('click', addRule);

            // Add enter key support for adding rules
            document.getElementById('wordInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addRule();
                }
            });
        });

        // Drag and Drop Functionality
function initDragAndDrop() {
    const pdfLabel = document.querySelector('label[for="pdfFiles"]');
    const zipLabel = document.querySelector('label[for="zipFile"]');
    
    // Prevent default drag behaviors on the whole document
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    // PDF Drop Zone
    ['dragenter', 'dragover'].forEach(eventName => {
        pdfLabel.addEventListener(eventName, () => {
            pdfLabel.classList.add('drag-over');
        }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        pdfLabel.addEventListener(eventName, () => {
            pdfLabel.classList.remove('drag-over');
        }, false);
    });
    
    pdfLabel.addEventListener('drop', handlePDFDrop, false);
    
    // ZIP Drop Zone
    ['dragenter', 'dragover'].forEach(eventName => {
        zipLabel.addEventListener(eventName, () => {
            zipLabel.classList.add('drag-over');
        }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        zipLabel.addEventListener(eventName, () => {
            zipLabel.classList.remove('drag-over');
        }, false);
    });
    
    zipLabel.addEventListener('drop', handleZIPDrop, false);
}

// Handle PDF drop
function handlePDFDrop(e) {
    const dt = e.dataTransfer;
    const files = Array.from(dt.files);
    
    console.log('PDF files dropped:', files.length);
    
    let addedCount = 0;
    
    files.forEach(file => {
        console.log('Checking dropped file:', file.name, 'Type:', file.type);
        
        if (file.type === 'application/pdf') {
            // Check if file already exists
            const isDuplicate = uploadedFiles.some(existingFile => 
                existingFile.name === file.name && existingFile.size === file.size
            );
            
            if (!isDuplicate) {
                uploadedFiles.push(file);
                addedCount++;
                console.log('Added dropped file:', file.name);
            } else {
                console.log('Duplicate dropped file:', file.name);
            }
        } else {
            console.log('Not a PDF, skipping:', file.name);
            alert(`${file.name} is not a PDF file`);
        }
    });
    
    console.log(`Total added: ${addedCount}, Total files now: ${uploadedFiles.length}`);
    displayFiles();
    updateProcessButton();
}

// Handle ZIP drop
async function handleZIPDrop(e) {
    const dt = e.dataTransfer;
    const files = Array.from(dt.files);
    
    if (files.length === 0) return;
    
    const file = files[0]; // Take only the first file
    
    if (!file.name.toLowerCase().endsWith('.zip')) {
        alert('Please drop a ZIP file');
        return;
    }
    
    console.log('ZIP file dropped:', file.name);

    try {
        const zip = await JSZip.loadAsync(file);
        let pdfCount = 0;
        let duplicateCount = 0;

        for (const [filename, zipEntry] of Object.entries(zip.files)) {
            if (!zipEntry.dir && filename.toLowerCase().endsWith('.pdf')) {
                const blob = await zipEntry.async('blob');
                const pdfFile = new File([blob], filename, { type: 'application/pdf' });
                
                console.log('Checking ZIP file:', pdfFile.name, 'Size:', pdfFile.size);
                
                // Check if file already exists
                const isDuplicate = uploadedFiles.some(existingFile => 
                    existingFile.name === pdfFile.name && existingFile.size === pdfFile.size
                );
                
                if (!isDuplicate) {
                    uploadedFiles.push(pdfFile);
                    pdfCount++;
                    console.log('Added from ZIP:', pdfFile.name);
                } else {
                    duplicateCount++;
                    console.log('Duplicate in ZIP:', pdfFile.name);
                }
            }
        }

        console.log(`Extracted ${pdfCount} PDFs, skipped ${duplicateCount} duplicates. Total files: ${uploadedFiles.length}`);
        
        if (pdfCount > 0) {
            alert(`Successfully extracted ${pdfCount} PDF file(s) from ZIP!`);
        }
        if (duplicateCount > 0) {
            alert(`Skipped ${duplicateCount} duplicate file(s)`);
        }
        
        displayFiles();
        updateProcessButton();
    } catch (error) {
        console.error('Error reading dropped ZIP file:', error);
        alert('Error reading ZIP file. Please ensure it contains valid PDF files.');
    }
}
    


// Particle Background System
const canvas = document.getElementById('particleCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const mouse = {
    x: window.innerWidth / 2,
    y: window.innerHeight / 2,
    radius: 150
};

window.addEventListener('mousemove', (e) => {
    mouse.x = e.x;
    mouse.y = e.y;
});

class Particle {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 3 + 1;
        this.baseSize = this.size;
        this.speedX = (Math.random() - 0.5) * 0.5;
        this.speedY = (Math.random() - 0.5) * 0.5;
        this.color = this.getRandomColor();
        this.pulseSpeed = Math.random() * 0.02 + 0.01;
        this.pulsePhase = Math.random() * Math.PI * 2;
    }

    getRandomColor() {
        const colors = [
            'rgba(255, 107, 0, 0.6)',   // Orange
            'rgba(255, 153, 51, 0.6)',  // Bright orange
            'rgba(255, 204, 0, 0.6)',   // Yellow-orange
            'rgba(255, 122, 26, 0.5)'   // Medium orange
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    update() {
        // Move particle
        this.x += this.speedX;
        this.y += this.speedY;

        // Wrap around screen
        if (this.x > canvas.width) this.x = 0;
        if (this.x < 0) this.x = canvas.width;
        if (this.y > canvas.height) this.y = 0;
        if (this.y < 0) this.y = canvas.height;

        // Pulse effect
        this.pulsePhase += this.pulseSpeed;
        this.size = this.baseSize + Math.sin(this.pulsePhase) * 1.5;

        // Attract to mouse
        const dx = mouse.x - this.x;
        const dy = mouse.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < mouse.radius) {
            const force = (mouse.radius - distance) / mouse.radius;
            const angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * force * 2;
            this.y += Math.sin(angle) * force * 2;
        }
    }

    draw() {
        // Ensure size is always positive
        const drawSize = Math.abs(this.size);
        if (drawSize < 0.1) return;

        ctx.beginPath();
        ctx.arc(this.x, this.y, drawSize, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// Create particles
const particles = [];
const particleCount = 100;

for (let i = 0; i < particleCount; i++) {
    particles.push(new Particle());
}

// Connect nearby particles
function connectParticles() {
    for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 100) {
                const opacity = (1 - distance / 100) * 0.3;
                ctx.strokeStyle = `rgba(255, 153, 51, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(particles[i].x, particles[i].y);
                ctx.lineTo(particles[j].x, particles[j].y);
                ctx.stroke();
            }
        }
    }
}

// Animation loop
function animate() {
    // Clear with fade effect for trails
    ctx.fillStyle = 'rgba(42, 21, 6, 0.1)'; // Match your background color
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update and draw particles
    particles.forEach(particle => {
        particle.update();
        particle.draw();
    });

    // Connect particles
    connectParticles();

    requestAnimationFrame(animate);
}

animate();

// Export detailed Excel report with color-coded terms
async function exportDetailedCSV() {
    if (detailedReport.length === 0) {
        alert('No data to export. Please process files first.');
        return;
    }

    try {
        // Load ExcelJS library if not already loaded
        if (typeof ExcelJS === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js';
            document.head.appendChild(script);
            await new Promise(resolve => script.onload = resolve);
        }

        // Create a new workbook using ExcelJS
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('Highlight Report');

        // Set column widths
        worksheet.columns = [
            { header: 'Filename', key: 'filename', width: 40 },
            { header: 'Term', key: 'term', width: 30 },
            { header: 'Pages', key: 'pages', width: 15 },
            { header: 'Total Count', key: 'count', width: 12 }
        ];

        // Style the header row - only the 4 header cells (not full row)
        const headerRow = worksheet.getRow(1);
        for (let col = 1; col <= 4; col++) {
            const cell = headerRow.getCell(col);
            cell.font = { bold: true, color: { argb: 'FFFFFFFF' }, size: 11 };
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFFF6B00' } // Orange color
            };
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
        }

        // Collect file data with term colors
        const fileRows = [];
        
        detailedReport.forEach(fileReport => {
            const filename = fileReport.filename;
            
            // Collect all terms found in this file
            const termsInFile = [];
            
            fileReport.termDetails.forEach(termDetail => {
                if (termDetail.count > 0) {
                    termsInFile.push({
                        term: termDetail.term,
                        color: termDetail.color,
                        pages: termDetail.pages.join(','),
                        count: termDetail.count
                    });
                }
            });
            
            // If file has highlights, add row for it
            if (termsInFile.length > 0) {
                const allPages = [...new Set(termsInFile.flatMap(t => t.pages.split(',')))].sort((a, b) => parseInt(a) - parseInt(b)).join(',');
                const totalCount = termsInFile.reduce((sum, t) => sum + t.count, 0);

                fileRows.push({
                    filename: filename,
                    terms: termsInFile,
                    pages: allPages,
                    totalCount: totalCount
                });
            }
        });

        // Add data rows - one row per file, combine terms with semicolon
        fileRows.forEach(row => {
            const newRow = worksheet.addRow({
                filename: row.filename,
                term: row.terms.map(t => t.term).join(';'),
                pages: row.pages,
                count: row.totalCount
            });

            // Style the Term cell with rich text and black background
            const termCell = newRow.getCell(2); // Column B (Term)

            // Build rich text with each term in its own color
            const richText = [];
            row.terms.forEach((termData, idx) => {
                richText.push({
                    text: termData.term,
                    font: {
                        color: { argb: 'FF' + termData.color.replace('#', '') },
                        bold: true,
                        size: 11
                    }
                });

                // Add semicolon separator in white
                if (idx < row.terms.length - 1) {
                    richText.push({
                        text: ';',
                        font: {
                            color: { argb: 'FFFFFFFF' },
                            bold: true,
                            size: 11
                        }
                    });
                }
            });

            termCell.value = { richText: richText };
            termCell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FF000000' } // Black background
            };
            termCell.alignment = { vertical: 'middle', horizontal: 'left' };
        });

        // Track total count for summary
        let grandTotal = 0;

        // Add rows for files with NO terms found (NULL rows in red)
        detailedReport.forEach(fileReport => {
            const totalHighlightsInFile = fileReport.termDetails.reduce((sum, term) => sum + term.count, 0);
            if (totalHighlightsInFile === 0) {
                const nullRow = worksheet.addRow({
                    filename: fileReport.filename,
                    term: 'NULL',
                    pages: 'NULL',
                    count: 0
                });

                // Apply red color to all cells in this row
                nullRow.eachCell((cell) => {
                    cell.font = {
                        color: { argb: 'FFFF0000' }, // Red text
                        bold: true,
                        size: 11
                    };
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                });
            }
        });

        // Calculate grand total from fileRows
        grandTotal = fileRows.reduce((sum, row) => sum + row.totalCount, 0);

        // Add a total row at the end
        const totalRow = worksheet.addRow({
            filename: '',
            term: '',
            pages: '',
            count: `Total ${grandTotal}`
        });

        // Style the total row - bold and bigger font
        const totalCell = totalRow.getCell(4); // Total Count column
        totalCell.font = {
            bold: true,
            size: 14, // Bigger font
            color: { argb: 'FF000000' }
        };
        totalCell.alignment = { vertical: 'middle', horizontal: 'left' };

        // Generate Excel file using ExcelJS
        const buffer = await workbook.xlsx.writeBuffer();
        const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const link = document.createElement('a');
        link.href = url;
        link.download = `pdf-highlighter-report-${Date.now()}.xlsx`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    
    // Show success message
    const exportBtn = document.getElementById('exportCSVBtn');
    const originalText = exportBtn.textContent;
    exportBtn.textContent = '✓ Excel Downloaded!';
    exportBtn.style.background = 'linear-gradient(135deg, #00aa00, #00dd00)';
    
    setTimeout(() => {
        exportBtn.textContent = originalText;
        exportBtn.style.background = 'linear-gradient(135deg, rgba(255, 160, 51, 0.15), rgba(255, 160, 51, 0.15))';
    }, 9000);
    
    console.log('Excel report exported successfully!');
    } catch (error) {
        console.error('Error exporting Excel:', error);
        alert('Error creating Excel file. Please try again.');
    }
}

